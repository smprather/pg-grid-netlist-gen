"""SPICE netlist writer."""

from __future__ import annotations

from collections import defaultdict
from pathlib import Path
from typing import TextIO

from pg_grid_netlist_gen.config import Config
from pg_grid_netlist_gen.geometry import Grid


def _first_pin_name_of_type(cell_cfg, pin_type: str) -> str | None:
    return next((p.name for p in cell_cfg.pins if p.type == pin_type), None)


def _write_chain_stimulus(f: TextIO, grid: Grid, config: Config):
    f.write("* === Chain Input Stimulus ===\n")
    stimulus_cfg = config.spice_netlist.chain_input_stimulus
    power_voltage = config.pg_nets.power.voltage

    input_pin = next(
        (p.name for p in config.standard_cells[0].pins if p.direction == "input" and p.type == "signal"),
        None,
    )
    if input_pin is None:
        return

    # Find all unique chain input nets
    input_nets = {c.pin_connections.get(input_pin) for c in grid.cells if c.pin_connections.get(input_pin, '').startswith("CHAIN_")}

    for net in sorted(input_nets):
        if net:
            f.write(
                f"V_{net} {net} 0 PULSE(0 {power_voltage} 0 "
                f"{stimulus_cfg['transition_time']}{config.units.time} "
                f"{stimulus_cfg['transition_time']}{config.units.time} "
                f"{(stimulus_cfg['period'] / 2)}{config.units.time} "
                f"{stimulus_cfg['period']}{config.units.time})\n"
            )
    f.write("\n")

def _write_chain_loads(f: TextIO, grid: Grid, config: Config):
    f.write("* === Cell-to-Cell Loads ===\n")
    load_cfg = config.spice_netlist.standard_cell_output_load
    last_load_cfg = load_cfg['last_buffer_in_chain']

    output_pin = next(
        (p.name for p in config.standard_cells[0].pins if p.direction == "output" and p.type == "signal"),
        None,
    )
    input_pin = next(
        (p.name for p in config.standard_cells[0].pins if p.direction == "input" and p.type == "signal"),
        None,
    )
    if output_pin is None or input_pin is None:
        return

    for cell in grid.cells:
        output_net = cell.pin_connections.get(output_pin)
        if not output_net or not output_net.lower().startswith("chain_"):
            continue

        # Check if this is the last cell in a chain
        is_last_in_chain = not any(output_net == c.pin_connections.get(input_pin) for c in grid.cells)

        if is_last_in_chain:
            r = last_load_cfg['resistance']
            c_f = _cap_value_to_f(last_load_cfg['capacitance'], config.units.capacitance)
            f.write(f"R_{output_net}_load {output_net} 0 {_format_value(r)}\n")
            f.write(f"C_{output_net}_load {output_net} 0 {_format_value(c_f)}\n")
        else:
            r = load_cfg['resistance']
            c_f = _cap_value_to_f(load_cfg['capacitance'], config.units.capacitance)
            n_seg = max(1, int(load_cfg.get("number_pi_segments", 1)))
            r_per = r / n_seg
            c_per_f = c_f / (n_seg + 1)
            node = output_net
            for seg_idx in range(n_seg):
                next_node = f"{output_net}_pi_{seg_idx+1}"
                f.write(f"C_{output_net}_piC_{seg_idx} {node} 0 {_format_value(c_per_f)}\n")
                f.write(f"R_{output_net}_piR_{seg_idx} {node} {next_node} {_format_value(r_per)}\n")
                node = next_node
            f.write(f"C_{output_net}_piC_{n_seg} {node} 0 {_format_value(c_per_f)}\n")
    f.write("\n")


def write_netlist(grid: Grid, config: Config, output_path: str | Path) -> None:
    """Write the SPICE netlist to a file."""
    output_path = Path(output_path)
    output_path.parent.mkdir(parents=True, exist_ok=True)

    with open(output_path, "w") as f:
        _write_header(f, config)
        _write_sources(f, grid, config)
        _write_chain_stimulus(f, grid, config)
        _write_subckt_stubs(f, config)
        _write_resistors(f, grid)
        _write_via_resistors(f, grid)
        _write_capacitors(f, grid)
        _write_cells(f, grid, config)
        _write_chain_loads(f, grid, config)
        _write_analysis(f, config)
        _write_measurements(f, grid, config)
        f.write("\n.end\n")


def _write_header(f: TextIO, config: Config) -> None:
    f.write(f"* Power Grid Netlist - {config.beol_stack.technology}\n")
    f.write("* Generated by pg_grid_netlist_gen\n")

    grid_size_y_um = config.grid.size["rows"] * config.standard_cell_placement.row_height
    grid_size_x_um = config.grid.size["sites"] * config.standard_cell_placement.site_width

    f.write(
        f"* Grid: {grid_size_x_um:.2f}um x "
        f"{grid_size_y_um:.2f}um\n"
    )
    f.write(f"* Layers: {len(config.beol_stack.layers)}\n")
    f.write("\n")

def _write_sources(f: TextIO, grid: Grid, config: Config) -> None:
    f.write("* === Voltage Sources ===\n")
    power_net = config.pg_nets.power.name
    power_voltage = config.pg_nets.power.voltage
    ground_net = config.pg_nets.ground.name
    if grid.plocs:
        for i, ploc in enumerate(grid.plocs):
            if ploc.net == power_net:
                src = f"{power_net}_src_{i}"
                f.write(f"V{power_net}_{i} {src} 0 DC {power_voltage}\n")
                f.write(f"R{power_net}_src_{i} {src} {ploc.node_name} 1e-3\n")
            elif ploc.net == ground_net:
                src = f"{ground_net}_src_{i}"
                f.write(f"V{ground_net}_{i} {src} 0 DC 0\n")
                f.write(f"R{ground_net}_src_{i} {src} {ploc.node_name} 1e-3\n")
    else:
        # Fallback when no PLOCs are generated.
        power_node = next((n.name for n in grid.nodes.values() if n.net == power_net), power_net)
        ground_node = next((n.name for n in grid.nodes.values() if n.net == ground_net), ground_net)
        f.write(f"V{power_net} {power_net}_src 0 DC {power_voltage}\n")
        f.write(f"V{ground_net} {ground_net}_src 0 DC 0\n")
        f.write(f"R{power_net}_src {power_net}_src {power_node} 1e-3\n")
        f.write(f"R{ground_net}_src {ground_net}_src {ground_node} 1e-3\n")
    f.write("\n")


def _write_subckt_stubs(f: TextIO, config: Config) -> None:
    f.write("* === Standard Cell Model Includes / Stubs ===\n")
    included_files: set[str] = set()
    for cell_cfg in config.standard_cells:
        netlist_file = (cell_cfg.spice_netlist_file or "").strip()
        if netlist_file:
            if netlist_file not in included_files:
                f.write(f'.include "{netlist_file}"\n')
                included_files.add(netlist_file)
            continue

        pins = cell_cfg.spice_port_order
        f.write(f".subckt {cell_cfg.name} {pins}\n")
        # Basic model for a buffer for simulation purposes
        f.write("a1 %vd(A) %vd(Y) nand\n")
        f.write(f".ends {cell_cfg.name}\n")
    f.write("\n")


def _write_resistors(f: TextIO, grid: Grid) -> None:
    f.write("* === Metal Segments (R) ===\n")
    for i, seg in enumerate(grid.segments):
        f.write(
            f"R_{seg.layer}_seg_{i} {seg.node_a.name} {seg.node_b.name} "
            f"{_format_value(seg.resistance)}\n"
        )
    f.write("\n")


def _write_via_resistors(f: TextIO, grid: Grid) -> None:
    f.write("* === Via Resistances ===\n")
    for i, via in enumerate(grid.vias):
        f.write(
            f"R_{via.via_layer}_{i} {via.node_top.name} {via.node_bot.name} "
            f"{_format_value(via.resistance)}\n"
        )
    f.write("\n")


def _write_capacitors(f: TextIO, grid: Grid) -> None:
    f.write("* === Node Capacitances ===\n")
    node_cap: dict[str, float] = defaultdict(float)
    for seg in grid.segments:
        c_total = seg.cap_plate + seg.cap_fringe
        half_c = c_total / 2.0
        node_cap[seg.node_a.name] += half_c
        node_cap[seg.node_b.name] += half_c

    for node_name, cap in sorted(node_cap.items()):
        if cap > 0:
            f.write(f"C_{node_name} {node_name} 0 {_format_value(cap)}\n")
    f.write("\n")


def _write_cells(f: TextIO, grid: Grid, config: Config) -> None:
    f.write("* === Standard Cell Instances ===\n")

    for cell in grid.cells:
        cell_cfg = next(c for c in config.standard_cells if c.name == cell.cell_name)
        pin_order = cell_cfg.spice_port_order.split()
        pin_nodes: list[str] = []
        for pin in pin_order:
            metal_node = cell.pin_connections.get(pin, f"NC_{pin}")
            pin_nodes.append(metal_node)
        pins_str = " ".join(pin_nodes)
        f.write(f"{cell.instance_name} {pins_str} {cell.cell_name}\n")
    f.write("\n")

def _write_analysis(f: TextIO, config: Config) -> None:
    f.write("* === Analysis ===\n")
    sim = config.spice_netlist.transient_simulation
    f.write(f".tran {sim['time_step']}{config.units.time} {sim['total_time']}{config.units.time}\n")
    f.write(".PROBE V(X*)\n")
    f.write("\n")

def _write_measurements(f: TextIO, grid: Grid, config: Config) -> None:
    f.write("* === IR Drop Measurements ===\n")
    cell_cfg_by_name = {c.name: c for c in config.standard_cells}

    window_cfg = config.spice_netlist.ir_drop_measurement["averaging_window"]
    power_voltage = config.pg_nets.power.voltage
    start_pct = float(window_cfg["start"]) / 100.0
    end_pct = float(window_cfg["end"]) / 100.0
    rise_start_level = power_voltage * start_pct
    rise_end_level = power_voltage * end_pct
    fall_start_level = power_voltage * (1.0 - start_pct)
    fall_end_level = power_voltage * (1.0 - end_pct)

    measure_names: list[str] = []

    for cell in grid.cells:
        cell_cfg = cell_cfg_by_name.get(cell.cell_name)
        if cell_cfg is None:
            continue

        power_pin_name = _first_pin_name_of_type(cell_cfg, "power")
        gnd_pin_name = _first_pin_name_of_type(cell_cfg, "ground")
        if not power_pin_name or not gnd_pin_name:
            continue

        vdd_node = cell.pin_connections.get(power_pin_name)
        vss_node = cell.pin_connections.get(gnd_pin_name)
        if not vdd_node or not vss_node:
            continue

        input_pin_name = next(
            (p.name for p in cell_cfg.pins if p.type == "signal" and p.direction == "input"),
            None,
        )
        output_pin_name = next(
            (p.name for p in cell_cfg.pins if p.type == "signal" and p.direction == "output"),
            None,
        )
        in_node = cell.pin_connections.get(input_pin_name) if input_pin_name else None
        out_node = cell.pin_connections.get(output_pin_name) if output_pin_name else None

        for out_edge in ("RISE", "FALL"):
            measure_name = f"IR_DROP_{cell.instance_name}_{out_edge}"
            if in_node and out_node:
                if cell_cfg.unateness == "negative":
                    in_edge = "FALL" if out_edge == "RISE" else "RISE"
                else:
                    in_edge = out_edge

                start_level = rise_start_level if in_edge == "RISE" else fall_start_level
                end_level = rise_end_level if out_edge == "RISE" else fall_end_level

                t_start = f"T_START_{cell.instance_name}_{out_edge}"
                t_end = f"T_END_{cell.instance_name}_{out_edge}"
                f.write(
                    f".measure tran {t_start} WHEN v({in_node})={_format_value(start_level)} {in_edge}=1\n"
                )
                f.write(
                    f".measure tran {t_end} WHEN v({out_node})={_format_value(end_level)} {out_edge}=1\n"
                )
                f.write(
                    f".measure tran {measure_name} "
                    f"AVG 'v({vdd_node}) - v({vss_node})' FROM='{t_start}' TO='{t_end}'\n"
                )
            else:
                # Fallback if signal pins are unavailable for this cell.
                sim_total_time = config.spice_netlist.transient_simulation["total_time"]
                measure_time = sim_total_time / 2.0
                f.write(
                    f".measure tran {measure_name} "
                    f"find 'v({vdd_node}) - v({vss_node})' at={measure_time}{config.units.time}\n"
                )
            measure_names.append(measure_name)

    f.write("\n")
    if measure_names:
        if len(measure_names) == 1:
            f.write(f".measure tran MAX_IR_DROP PARAM='{measure_names[0]}'\n")
            f.write(f".measure tran AVG_IR_DROP PARAM='{measure_names[0]}'\n")
        else:
            f.write(f".measure tran MAX_IR_DROP PARAM='max({', '.join(measure_names)})'\n")
            avg_expr = f"({' + '.join(measure_names)})/{len(measure_names)}"
            f.write(f".measure tran AVG_IR_DROP PARAM='{avg_expr}'\n")
    f.write("\n")


def _format_value(value: float) -> str:
    """Format a value with engineering notation for SPICE."""
    if value == 0:
        return "0"
    abs_val = abs(value)
    if abs_val >= 1e6:
        return f"{value:.4g}MEG"
    if abs_val >= 1e3:
        return f"{value:.4g}k"
    if abs_val >= 1:
        return f"{value:.4g}"
    if abs_val >= 1e-3:
        return f"{value * 1e3:.4g}m"
    if abs_val >= 1e-6:
        return f"{value * 1e6:.4g}u"
    if abs_val >= 1e-9:
        return f"{value * 1e9:.4g}n"
    if abs_val >= 1e-12:
        return f"{value * 1e12:.4g}p"
    if abs_val >= 1e-15:
        return f"{value * 1e15:.4g}f"
    return f"{value:.4e}"


def _cap_value_to_f(value: float, unit: str) -> float:
    unit_map = {
        "f": 1.0,
        "pf": 1e-12,
        "ff": 1e-15,
        "nf": 1e-9,
        "uf": 1e-6,
    }
    key = unit.strip().lower()
    if key not in unit_map:
        raise ValueError(
            f"Unsupported units.capacitance '{unit}'. Supported: f, pf, ff, nf, uf"
        )
    return float(value) * unit_map[key]
