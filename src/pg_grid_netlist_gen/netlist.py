"""SPICE netlist writer."""

from __future__ import annotations

from collections import defaultdict
from pathlib import Path
from typing import TextIO

from pg_grid_netlist_gen.config import Config
from pg_grid_netlist_gen.geometry import Grid


def write_netlist(grid: Grid, config: Config, output_path: str | Path) -> None:
    """Write the SPICE netlist to a file."""
    output_path = Path(output_path)
    output_path.parent.mkdir(parents=True, exist_ok=True)

    with open(output_path, "w") as f:
        _write_header(f, config)
        _write_subckt_stubs(f, config)
        _write_resistors(f, grid)
        _write_via_resistors(f, grid)
        _write_capacitors(f, grid)
        _write_cells(f, grid, config)
        f.write("\n.end\n")


def _write_header(f: TextIO, config: Config) -> None:
    f.write(f"* Power Grid Netlist - {config.beol_stack.technology}\n")
    f.write("* Generated by pg_grid_netlist_gen\n")
    f.write(
        f"* Grid: {config.grid.grid_size.x / 1000:.0f}um x "
        f"{config.grid.grid_size.y / 1000:.0f}um\n"
    )
    f.write(f"* Layers: {len(config.beol_stack.layers)}\n")
    f.write("\n")


def _write_subckt_stubs(f: TextIO, config: Config) -> None:
    for cell_cfg in config.standard_cells:
        pins = " ".join(cell_cfg.instance_pins)
        f.write(f".subckt {cell_cfg.cell} {pins}\n")
        f.write(f".ends {cell_cfg.cell}\n")
    f.write("\n")


def _write_resistors(f: TextIO, grid: Grid) -> None:
    f.write("* === Metal Segments (R) ===\n")
    current_layer = ""
    for i, seg in enumerate(grid.segments):
        if seg.layer != current_layer:
            current_layer = seg.layer
            f.write(f"* Layer: {current_layer}\n")
        f.write(
            f"R_{seg.layer}_seg_{i} {seg.node_a.name} {seg.node_b.name} "
            f"{_format_value(seg.resistance)}\n"
        )
    f.write("\n")


def _write_via_resistors(f: TextIO, grid: Grid) -> None:
    f.write("* === Via Resistances ===\n")
    for i, via in enumerate(grid.vias):
        f.write(
            f"R_{via.via_layer}_{i} {via.node_top.name} {via.node_bot.name} "
            f"{_format_value(via.resistance)}\n"
        )
    f.write("\n")


def _write_capacitors(f: TextIO, grid: Grid) -> None:
    f.write("* === Node Capacitances ===\n")
    f.write("* Aggregated C/2 contributions per node\n")

    # Aggregate capacitance per node: each node gets C/2 from each connected segment
    node_cap: dict[str, float] = defaultdict(float)
    for seg in grid.segments:
        c_total = seg.cap_plate + seg.cap_fringe
        half_c = c_total / 2.0
        node_cap[seg.node_a.name] += half_c
        node_cap[seg.node_b.name] += half_c

    for node_name in sorted(node_cap.keys()):
        cap = node_cap[node_name]
        if cap > 0:
            f.write(f"C_{node_name} {node_name} 0 {_format_value(cap)}\n")
    f.write("\n")


def _write_cells(f: TextIO, grid: Grid, config: Config) -> None:
    f.write("* === Standard Cell Instances ===\n")
    cell_cfg = config.standard_cells[0]
    for cell in grid.cells:
        # SPICE instance line: XNAME pin1 pin2 ... CELLNAME
        pin_nodes = [cell.pin_connections.get(p, "NC") for p in cell_cfg.instance_pins]
        pins_str = " ".join(pin_nodes)
        f.write(f"{cell.instance_name} {pins_str} {cell.cell_name}\n")
    f.write("\n")


def _format_value(value: float) -> str:
    """Format a value with engineering notation for SPICE."""
    if value == 0:
        return "0"
    abs_val = abs(value)
    if abs_val >= 1e6:
        return f"{value:.4g}MEG"
    if abs_val >= 1e3:
        return f"{value:.4g}k"
    if abs_val >= 1:
        return f"{value:.4g}"
    if abs_val >= 1e-3:
        return f"{value * 1e3:.4g}m"
    if abs_val >= 1e-6:
        return f"{value * 1e6:.4g}u"
    if abs_val >= 1e-9:
        return f"{value * 1e9:.4g}n"
    if abs_val >= 1e-12:
        return f"{value * 1e12:.4g}p"
    if abs_val >= 1e-15:
        return f"{value * 1e15:.4g}f"
    return f"{value:.4e}"
